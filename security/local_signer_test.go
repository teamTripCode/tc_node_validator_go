package security

import (
	"bytes"
	"crypto/ed25519"
	"os"
	"path/filepath"
	"testing"
)

// setupTestDir creates a temporary directory for test key files.
func setupTestDir(t *testing.T) string {
	t.Helper() // Marks this function as a test helper
	tempDir := t.TempDir()
	// No need to explicitly call os.MkdirAll, t.TempDir() handles it.
	// No need to explicitly call os.RemoveAll, t.TempDir() handles cleanup.
	return tempDir
}

func TestNewLocalSigner_KeyGenerationAndLoading(t *testing.T) {
	tempDir := setupTestDir(t)
	testPassphrase := "test-passphrase-123"
	keyFileName := "node_key.enc" // as used in local_signer.go

	// 1. Key Generation
	t.Run("KeyGeneration", func(t *testing.T) {
		signer1, err := NewLocalSigner(tempDir, testPassphrase)
		if err != nil {
			t.Fatalf("NewLocalSigner (generation) failed: %v", err)
		}
		if signer1 == nil {
			t.Fatalf("NewLocalSigner (generation) returned nil signer")
		}

		pubKey1 := signer1.PublicKey()
		if len(pubKey1) == 0 {
			t.Errorf("signer1.PublicKey() is empty")
		}
		addr1 := signer1.Address()
		if addr1 == "" {
			t.Errorf("signer1.Address() is empty")
		}

		// Verify key file was created
		keyFilePath := filepath.Join(tempDir, keyFileName)
		if _, err := os.Stat(keyFilePath); os.IsNotExist(err) {
			t.Errorf("key file %s was not created", keyFilePath)
		}
	})

	// 2. Key Loading
	t.Run("KeyLoading", func(t *testing.T) {
		// At this point, the key file from the "KeyGeneration" sub-test should exist.
		// We need to ensure that the state from the first call (signer1) is available or re-create it
		// to compare. For simplicity in this test structure, we'll create signer1 again within
		// the scope of what we want to compare against, or make signer1 accessible.
		// Let's make it simpler: create signer1, then create signer2 and compare.

		signer1, err := NewLocalSigner(tempDir, testPassphrase) // This will generate if not present, or load if test is re-run/split
		if err != nil {
			t.Fatalf("NewLocalSigner (pre-load for comparison) failed: %v", err)
		}

		signer2, err := NewLocalSigner(tempDir, testPassphrase) // This should load the key generated by signer1
		if err != nil {
			t.Fatalf("NewLocalSigner (loading) failed: %v", err)
		}
		if signer2 == nil {
			t.Fatalf("NewLocalSigner (loading) returned nil signer")
		}

		if signer1.Address() != signer2.Address() {
			t.Errorf("Address mismatch: signer1.Address() = %s, signer2.Address() = %s", signer1.Address(), signer2.Address())
		}
		if !bytes.Equal(signer1.PublicKey(), signer2.PublicKey()) {
			t.Errorf("PublicKey mismatch between signer1 and signer2")
		}

		// Test signing with the loaded key (signer2)
		dataToSign := []byte("test message for loaded key")
		signature, err := signer2.Sign(dataToSign)
		if err != nil {
			t.Errorf("signer2.Sign() failed: %v", err)
		}
		if len(signature) == 0 {
			t.Errorf("signer2.Sign() returned empty signature")
		}
		isValid := ed25519.Verify(signer2.PublicKey(), dataToSign, signature)
		if !isValid {
			t.Errorf("ed25519.Verify failed for signature from loaded key (signer2)")
		}
	})
}

func TestLocalSigner_SignAndVerify(t *testing.T) {
	tempDir := setupTestDir(t)
	testPassphrase := "sign-verify-pass"

	signer, err := NewLocalSigner(tempDir, testPassphrase)
	if err != nil {
		t.Fatalf("NewLocalSigner failed: %v", err)
	}
	if signer == nil {
		t.Fatalf("NewLocalSigner returned a nil signer")
	}

	dataToSign := []byte("test message for signing")

	signature, err := signer.Sign(dataToSign)
	if err != nil {
		t.Fatalf("signer.Sign() failed: %v", err)
	}
	if len(signature) == 0 {
		t.Fatalf("signer.Sign() returned an empty signature")
	}

	publicKey := signer.PublicKey()
	if len(publicKey) == 0 {
		t.Fatalf("signer.PublicKey() returned an empty public key")
	}

	// Verify original signature
	isValid := ed25519.Verify(publicKey, dataToSign, signature)
	if !isValid {
		t.Errorf("ed25519.Verify failed for original data and signature")
	}

	// Test with tampered data
	tamperedData := []byte("tampered test message for signing")
	isTamperedValid := ed25519.Verify(publicKey, tamperedData, signature)
	if isTamperedValid {
		t.Errorf("ed25519.Verify succeeded for tampered data, but should have failed")
	}

	// Test with a different public key (generate a dummy one)
	_, otherPublicKey, _ := ed25519.GenerateKey(nil) // Using nil reader is okay for dummy key not needing crypto security
	isOtherKeyValid := ed25519.Verify(otherPublicKey, dataToSign, signature)
	if isOtherKeyValid {
		t.Errorf("ed25519.Verify succeeded with a different public key, but should have failed")
	}
}

func TestNewLocalSigner_InvalidPassphrase(t *testing.T) {
	tempDir := setupTestDir(t)
	initialPassphrase := "correct-passphrase"
	wrongPassphrase := "wrong-passphrase"

	// 1. Generate and save a key with the initial passphrase
	_, err := NewLocalSigner(tempDir, initialPassphrase)
	if err != nil {
		t.Fatalf("NewLocalSigner (initial key generation) failed: %v", err)
	}

	// 2. Attempt to load the key with an incorrect passphrase
	signer2, err := NewLocalSigner(tempDir, wrongPassphrase)
	if err == nil {
		t.Errorf("NewLocalSigner succeeded with wrong passphrase, but should have failed")
		if signer2 != nil {
			// If it somehow succeeded, log more info, though this path indicates a test logic failure or bug in NewLocalSigner
			t.Logf("Signer2 address if wrongly succeeded: %s", signer2.Address())
		}
	} else {
		// Check if the error message indicates decryption failure (optional, but good for confirming cause)
		// This depends on the exact error message returned by loadAndDecryptKey on gcm.Open failure.
		// A common error is "cipher: message authentication failed".
		// We can use strings.Contains(err.Error(), "failed to decrypt key") or similar from local_signer.go error wrapping.
		expectedErrorSubstring := "failed to decrypt key" // From loadAndDecryptKey's error wrapping
		if !bytes.Contains([]byte(err.Error()), []byte(expectedErrorSubstring)) {
			t.Logf("NewLocalSigner failed with wrong passphrase as expected, but error message '%s' did not contain '%s'", err.Error(), expectedErrorSubstring)
		} else {
			t.Logf("NewLocalSigner failed with wrong passphrase as expected: %v", err)
		}
	}
	if signer2 != nil {
		t.Errorf("NewLocalSigner returned a non-nil signer with wrong passphrase")
	}
}

func TestNewLocalSigner_EmptyPassphrase(t *testing.T) {
	tempDir := setupTestDir(t)

	signer, err := NewLocalSigner(tempDir, "") // Attempt with empty passphrase
	if err == nil {
		t.Errorf("NewLocalSigner succeeded with an empty passphrase, but should have failed.")
	} else {
		// Check for the specific error message if desired, e.g., "passphrase cannot be empty"
		expectedErrorSubstring := "passphrase cannot be empty"
		if !bytes.Contains([]byte(err.Error()), []byte(expectedErrorSubstring)) {
			t.Logf("NewLocalSigner failed with empty passphrase as expected, but error message '%s' did not contain '%s'", err.Error(), expectedErrorSubstring)
		} else {
			t.Logf("NewLocalSigner failed with empty passphrase as expected: %v", err)
		}
	}
	if signer != nil {
		t.Errorf("NewLocalSigner returned a non-nil signer with an empty passphrase")
	}
}
